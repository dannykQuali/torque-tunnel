spec_version: 2
description: |
  Execute shell commands on a remote host via SSH.
  This blueprint is designed to be called programmatically by the ShellAgent MCP tool
  to enable Copilot to run commands on remote servers for troubleshooting.

inputs:
  agent:
    type: agent
    description: The Torque agent to use for execution
  timeout_minutes:
    type: string
    description: Maximum execution time in minutes before auto-termination
    default: '30'
  target_ip:
    type: string
    description: The IP address or hostname of the target server
  ssh_user:
    type: string
    description: The SSH username to connect with
  ssh_private_key:
    type: string
    description: The SSH private key in PEM format for authentication
    sensitive: true
  command_b64:
    type: string
    description: Base64-encoded shell command(s) to execute on the remote host
  init_commands_b64:
    type: string
    description: Base64-encoded init commands (e.g., proxy setup)
    default: ""
  finally_commands_b64:
    type: string
    description: Base64-encoded finally commands (cleanup, always runs)
    default: ""

outputs:
  command_output:
    value: '{{ .grains.remote_executor.activities.deploy.commands.run_ssh.outputs.command_output }}'
  exit_code:
    value: '{{ .grains.remote_executor.activities.deploy.commands.run_ssh.outputs.exit_code }}'
  execution_duration_ms:
    value: '{{ .grains.remote_executor.activities.deploy.commands.run_ssh.outputs.execution_duration_ms }}'

grains:
  remote_executor:
    kind: shell
    spec:
      agent:
        name: '{{ .inputs.agent }}'
      activities:
        deploy:
          commands:
            - name: run_ssh
              command: |
                # Disable exit on error so we always reach the export statements
                set +e
                
                echo "=== Beginning of execution ====================================================================================================================="
                
                # Initialize variables with defaults
                OUTPUT_FILE=$(mktemp)
                EXIT_CODE_FILE=$(mktemp)
                echo "1" > "$EXIT_CODE_FILE"  # Default exit code
                KEY_FILE=""
                REMOTE_SCRIPT=""
                CMD_FILE=""
                INIT_FILE=""
                FINALLY_FILE=""
                
                # Wrap the main logic in a function so we can capture any errors
                __run_main() {
                  # Save the private key to temp file
                  KEY_FILE=$(mktemp)
                  cat << 'KEYEOF' > "$KEY_FILE"
                {{ .inputs.ssh_private_key }}
                KEYEOF
                  chmod 600 "$KEY_FILE"
                  
                  REMOTE_SCRIPT=$(mktemp)
                  
                  # Decode base64 inputs to files
                  CMD_FILE=$(mktemp)
                  echo '{{ .inputs.command_b64 }}' | base64 -d > "$CMD_FILE"
                  
                  INIT_FILE=$(mktemp)
                  echo '{{ .inputs.init_commands_b64 }}' | base64 -d > "$INIT_FILE" 2>/dev/null || true
                  
                  FINALLY_FILE=$(mktemp)
                  echo '{{ .inputs.finally_commands_b64 }}' | base64 -d > "$FINALLY_FILE" 2>/dev/null || true
                  
                  # Build remote script
                  echo '#!/bin/bash' > "$REMOTE_SCRIPT"
                  
                  # Track exit code for proper propagation
                  echo '__EXIT_CODE=0' >> "$REMOTE_SCRIPT"
                  
                  # Add finally trap if provided - wrapped with </dev/null to prevent stdin reads
                  if [ -s "$FINALLY_FILE" ]; then
                    echo '__finally() {' >> "$REMOTE_SCRIPT"
                    echo '(' >> "$REMOTE_SCRIPT"
                    cat "$FINALLY_FILE" >> "$REMOTE_SCRIPT"
                    echo '' >> "$REMOTE_SCRIPT"
                    echo ') </dev/null' >> "$REMOTE_SCRIPT"
                    echo '}' >> "$REMOTE_SCRIPT"
                    echo 'trap __finally EXIT' >> "$REMOTE_SCRIPT"
                  fi
                  
                  # Add init commands if provided - check exit code and skip main if failed
                  # Use curly braces (not subshell) so exports persist
                  if [ -s "$INIT_FILE" ]; then
                    echo '{' >> "$REMOTE_SCRIPT"
                    cat "$INIT_FILE" >> "$REMOTE_SCRIPT"
                    echo '' >> "$REMOTE_SCRIPT"
                    echo '} </dev/null' >> "$REMOTE_SCRIPT"
                    echo '__EXIT_CODE=$?' >> "$REMOTE_SCRIPT"
                    echo 'if [ $__EXIT_CODE -ne 0 ]; then exit $__EXIT_CODE; fi' >> "$REMOTE_SCRIPT"
                  fi
                  
                  # Add main command - wrapped with </dev/null to prevent stdin reads from hanging
                  # since this is a non-interactive execution context
                  echo '(' >> "$REMOTE_SCRIPT"
                  cat "$CMD_FILE" >> "$REMOTE_SCRIPT"
                  echo '' >> "$REMOTE_SCRIPT"
                  echo ') </dev/null' >> "$REMOTE_SCRIPT"
                  
                  echo "=== Connecting to {{ .inputs.ssh_user }}@{{ .inputs.target_ip }} ==="
                  echo "=== Output (streaming) ========================================================================================================================="
                  
                  START_TIME=$(date +%s%3N 2>/dev/null || date +%s)000
                  ssh -o StrictHostKeyChecking=no \
                      -o UserKnownHostsFile=/dev/null \
                      -o LogLevel=ERROR \
                      -i "$KEY_FILE" \
                      "{{ .inputs.ssh_user }}@{{ .inputs.target_ip }}" \
                      "bash -s" < "$REMOTE_SCRIPT" 2>&1 | tee "$OUTPUT_FILE"
                  echo "${PIPESTATUS[0]}" > "$EXIT_CODE_FILE"
                  END_TIME=$(date +%s%3N 2>/dev/null || date +%s)000
                  EXEC_DURATION_MS=$((END_TIME - START_TIME))
                }
                
                # Run main logic - errors go to output file, stdout is already captured inside
                __run_main 2>> "$OUTPUT_FILE"
                
                # Always export outputs - this section MUST be reached
                COMMAND_OUTPUT_B64=$(base64 < "$OUTPUT_FILE" 2>/dev/null | tr -d '\n' || echo "")
                SSH_EXIT_CODE=$(cat "$EXIT_CODE_FILE" 2>/dev/null || echo "1")
                rm -f "$KEY_FILE" "$OUTPUT_FILE" "$EXIT_CODE_FILE" "$REMOTE_SCRIPT" "$CMD_FILE" "$INIT_FILE" "$FINALLY_FILE" 2>/dev/null || true
                
                export command_output="$COMMAND_OUTPUT_B64"
                export exit_code="$SSH_EXIT_CODE"
                export execution_duration_ms="${EXEC_DURATION_MS:-0}"
                
                echo ""
                echo "=== Command completed with exit code: $SSH_EXIT_CODE ==="
              outputs:
                - command_output
                - exit_code
                - execution_duration_ms

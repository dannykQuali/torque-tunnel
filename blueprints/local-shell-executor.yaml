spec_version: 2
description: |
  Execute shell commands directly on the Torque agent container.
  This blueprint runs commands locally on the agent without SSH to any remote host.
  Useful for running scripts, tools, or commands that don't require a target machine.

inputs:
  agent:
    type: agent
    description: The Torque agent to use for execution
  command_b64:
    type: string
    description: Base64-encoded shell command(s) to execute on the agent
  init_commands_b64:
    type: string
    description: Base64-encoded init commands (optional)
    default: ""
  finally_commands_b64:
    type: string
    description: Base64-encoded finally commands (optional)
    default: ""

outputs:
  command_output:
    value: '{{ .grains.local_executor.activities.deploy.commands.run_local.outputs.command_output }}'
  exit_code:
    value: '{{ .grains.local_executor.activities.deploy.commands.run_local.outputs.exit_code }}'

grains:
  local_executor:
    kind: shell
    spec:
      agent:
        name: '{{ .inputs.agent }}'
      activities:
        deploy:
          commands:
            - name: run_local
              command: |
                # Disable exit on error so we always reach the export statements
                set +e
                
                echo "=== Beginning of local execution ============================================================================================================="
                
                # Initialize variables with defaults
                OUTPUT_FILE=$(mktemp)
                CMD_EXIT_CODE=1
                SCRIPT_FILE=""
                INIT_FILE=""
                FINALLY_FILE=""
                COMBINED=""
                
                # Wrap the main logic in a function so we can capture any errors
                __run_main() {
                  SCRIPT_FILE=$(mktemp)
                  
                  # Decode base64 inputs directly to files
                  echo '{{ .inputs.command_b64 }}' | base64 -d > "$SCRIPT_FILE"
                  
                  INIT_FILE=$(mktemp)
                  echo '{{ .inputs.init_commands_b64 }}' | base64 -d > "$INIT_FILE" 2>/dev/null || true
                  
                  FINALLY_FILE=$(mktemp)
                  echo '{{ .inputs.finally_commands_b64 }}' | base64 -d > "$FINALLY_FILE" 2>/dev/null || true
                  
                  # Build combined script
                  COMBINED=$(mktemp)
                  echo '#!/bin/bash' > "$COMBINED"
                  
                  # Add finally trap if provided - wrapped with </dev/null to prevent stdin reads
                  if [ -s "$FINALLY_FILE" ]; then
                    echo '__finally() {' >> "$COMBINED"
                    echo '(' >> "$COMBINED"
                    cat "$FINALLY_FILE" >> "$COMBINED"
                    echo '' >> "$COMBINED"
                    echo ') </dev/null' >> "$COMBINED"
                    echo '}' >> "$COMBINED"
                    echo 'trap __finally EXIT' >> "$COMBINED"
                  fi
                  
                  # Add init commands if provided - use curly braces (not subshell) so exports persist
                  # Redirect stdin to /dev/null to prevent interactive prompts
                  if [ -s "$INIT_FILE" ]; then
                    echo "=== Running init commands ==="
                    echo '{' >> "$COMBINED"
                    cat "$INIT_FILE" >> "$COMBINED"
                    echo '' >> "$COMBINED"
                    echo '} </dev/null' >> "$COMBINED"
                  fi
                  
                  # Add main command - wrapped with </dev/null to prevent stdin reads
                  echo '(' >> "$COMBINED"
                  cat "$SCRIPT_FILE" >> "$COMBINED"
                  echo '' >> "$COMBINED"
                  echo ') </dev/null' >> "$COMBINED"
                  
                  chmod +x "$COMBINED"
                  
                  echo "=== Executing on agent container ==="
                  echo "=== Output (streaming) ========================================================================================================================="
                  
                  # Run the script (commands inside already have </dev/null protection)
                  bash "$COMBINED" 2>&1 | tee "$OUTPUT_FILE"
                  CMD_EXIT_CODE=${PIPESTATUS[0]}
                }
                
                # Run main logic, capturing any errors to the output file
                __run_main 2>&1 | tee -a "$OUTPUT_FILE"
                
                # Always export outputs - this section MUST be reached
                COMMAND_OUTPUT_B64=$(base64 < "$OUTPUT_FILE" 2>/dev/null | tr -d '\n' || echo "")
                rm -f "$OUTPUT_FILE" "$SCRIPT_FILE" "$INIT_FILE" "$FINALLY_FILE" "$COMBINED" 2>/dev/null || true
                
                export command_output="$COMMAND_OUTPUT_B64"
                export exit_code="$CMD_EXIT_CODE"
                
                echo ""
                echo "=== Command completed with exit code: $CMD_EXIT_CODE ==="
              outputs:
                - command_output
                - exit_code

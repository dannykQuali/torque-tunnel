spec_version: 2
description: |
  Execute shell commands directly on the Torque agent container.
  This blueprint runs commands locally on the agent without SSH to any remote host.
  Useful for running scripts, tools, or commands that don't require a target machine.

inputs:
  agent:
    type: agent
    description: The Torque agent to use for execution
  timeout_minutes:
    type: string
    description: Maximum execution time in minutes before auto-termination
    default: '30'
  command_b64:
    type: string
    description: Base64-encoded shell command(s) to execute on the agent
  init_commands_b64:
    type: string
    description: Base64-encoded init commands (optional)
    default: ""
  finally_commands_b64:
    type: string
    description: Base64-encoded finally commands (optional)
    default: ""

outputs:
  command_output:
    value: '{{ .grains.local_executor.activities.deploy.commands.run_local.outputs.command_output }}'
  exit_code:
    value: '{{ .grains.local_executor.activities.deploy.commands.run_local.outputs.exit_code }}'

grains:
  local_executor:
    kind: shell
    spec:
      agent:
        name: '{{ .inputs.agent }}'
      activities:
        deploy:
          commands:
            - name: run_local
              command: |
                # Disable exit on error so we always reach the export statements
                set +e
                
                echo "=== Beginning of local execution ============================================================================================================="
                
                # Initialize variables with defaults
                OUTPUT_FILE=$(mktemp)
                EXIT_CODE_FILE=$(mktemp)
                echo "1" > "$EXIT_CODE_FILE"  # Default exit code
                SCRIPT_FILE=""
                INIT_FILE=""
                FINALLY_FILE=""
                COMBINED=""
                
                # Wrap the main logic in a function so we can capture any errors
                __run_main() {
                  SCRIPT_FILE=$(mktemp)
                  
                  # Decode base64 inputs directly to files
                  echo '{{ .inputs.command_b64 }}' | base64 -d > "$SCRIPT_FILE"
                  
                  INIT_FILE=$(mktemp)
                  echo '{{ .inputs.init_commands_b64 }}' | base64 -d > "$INIT_FILE" 2>/dev/null || true
                  
                  FINALLY_FILE=$(mktemp)
                  echo '{{ .inputs.finally_commands_b64 }}' | base64 -d > "$FINALLY_FILE" 2>/dev/null || true
                  
                  # Build combined script
                  COMBINED=$(mktemp)
                  echo '#!/bin/bash' > "$COMBINED"
                  
                  # Track exit code for proper propagation
                  echo '__EXIT_CODE=0' >> "$COMBINED"
                  
                  # Add finally trap if provided - wrapped with </dev/null to prevent stdin reads
                  if [ -s "$FINALLY_FILE" ]; then
                    echo '__finally() {' >> "$COMBINED"
                    echo '(' >> "$COMBINED"
                    cat "$FINALLY_FILE" >> "$COMBINED"
                    echo '' >> "$COMBINED"
                    echo ') </dev/null' >> "$COMBINED"
                    echo '}' >> "$COMBINED"
                    echo 'trap __finally EXIT' >> "$COMBINED"
                  fi
                  
                  # Add init commands if provided - check exit code and skip main if failed
                  # Use curly braces (not subshell) so exports persist
                  if [ -s "$INIT_FILE" ]; then
                    echo "=== Running init commands ==="
                    echo '{' >> "$COMBINED"
                    cat "$INIT_FILE" >> "$COMBINED"
                    echo '' >> "$COMBINED"
                    echo '} </dev/null' >> "$COMBINED"
                    echo '__EXIT_CODE=$?' >> "$COMBINED"
                    echo 'if [ $__EXIT_CODE -ne 0 ]; then exit $__EXIT_CODE; fi' >> "$COMBINED"
                  fi
                  
                  # Add main command - wrapped with </dev/null to prevent stdin reads
                  echo '(' >> "$COMBINED"
                  cat "$SCRIPT_FILE" >> "$COMBINED"
                  echo '' >> "$COMBINED"
                  echo ') </dev/null' >> "$COMBINED"
                  
                  chmod +x "$COMBINED"
                  
                  echo "=== Executing on agent container ==="
                  echo "=== Output (streaming) ========================================================================================================================="
                  
                  # Run the script (commands inside already have </dev/null protection)
                  bash "$COMBINED" 2>&1 | tee "$OUTPUT_FILE"
                  echo "${PIPESTATUS[0]}" > "$EXIT_CODE_FILE"
                }
                
                # Run main logic - errors go to output file, stdout is already captured inside
                __run_main 2>> "$OUTPUT_FILE"
                
                # Always export outputs - this section MUST be reached
                COMMAND_OUTPUT_B64=$(base64 < "$OUTPUT_FILE" 2>/dev/null | tr -d '\n' || echo "")
                CMD_EXIT_CODE=$(cat "$EXIT_CODE_FILE" 2>/dev/null || echo "1")
                rm -f "$OUTPUT_FILE" "$EXIT_CODE_FILE" "$SCRIPT_FILE" "$INIT_FILE" "$FINALLY_FILE" "$COMBINED" 2>/dev/null || true
                
                export command_output="$COMMAND_OUTPUT_B64"
                export exit_code="$CMD_EXIT_CODE"
                
                echo ""
                echo "=== Command completed with exit code: $CMD_EXIT_CODE ==="
              outputs:
                - command_output
                - exit_code
